var g_map = new WeakMap();
var g_key_map = {k: 'map'};
var b_key2 = {k2: 0};

function hideWeakMap(map, level, initKey) {
  let prevMap = map;
  let prevKey = initKey;
  for (let i = 0; i < level; i++) {
    let thisMap = new WeakMap();
    prevMap.set(prevKey, thisMap);
    let thisKey = { 'h': i };
    //make thisKey reachable via prevKey
    thisMap.set(prevKey, thisKey);
    prevMap = thisMap;
    prevKey = thisKey;
    if (i == level - 1) {
      let retMap = new WeakMap();
      map.set(thisKey, retMap);
      return thisKey;
    }
  }
}

//Get the key for the hidden map, the return key is reachable as strong ref via weak maps, but should not be directly reachable when gc happens
function getHiddenKey(map, level, initKey) {
  let prevMap = map;
  let prevKey = initKey;
  for (let i = 0; i < level; i++) {
    let thisMap = prevMap.get(prevKey);
    let thisKey = thisMap.get(prevKey);
    prevMap = thisMap;
    prevKey = thisKey;
    if (i == level - 1) {
      return thisKey;
    }
  }
}

function build_ephemerons(map) {
    var key1 = {k1: 0};
    var key0 = {k0: 0};
    var val2 = key0;
    var val1 = {v1: 0};
    var val0 = key1;

    // var innerMapKey = hideWeakMap(map, 4, b_key0);
    // var innerMap = map.get(innerMapKey);
    var innerMap = g_map;

    innerMap.set(key0, val0); // E0
    innerMap.set(key1, val1); // E1
    innerMap.set(b_key2, val2); // E2
    // map.set(g_key_map, innerMap);    
}
build_ephemerons(g_map);
% CollectGarbage(null);